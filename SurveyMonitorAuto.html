<!DOCTYPE html>
<!-- Survey Monitor for Genesys Cloud -->
<html>
  <head>
    <meta name="robots" content="noindex" />
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Survey Monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Genesys CSS -->
    <link no-cors href="https://cdn.jsdelivr.net/npm/genesys-spark-components@4.138.2/dist/genesys-webcomponents/genesys-webcomponents.min.css" rel="stylesheet" />
    <script no-cors type="module" src="https://cdn.jsdelivr.net/npm/genesys-spark-components@4.138.2/dist/genesys-webcomponents/genesys-webcomponents.esm.min.js"></script>
    <!-- Genesys SDK -->
    <script src="https://sdk-cdn.mypurecloud.com/javascript/latest/purecloud-platform-client-v2.min.js"></script>
    <script src="https://sdk-cdn.mypurecloud.com/client-apps/2.6.7/purecloud-client-app-sdk.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: auto;
      }
      .content-wrapper {
        min-width: 1000px;
        min-height: 100%;
        padding: 20px;
      }
      .header-section {
        margin-bottom: 20px;
      }
      .config-section {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      .control-row {
        display: inline-flex;
        gap: 10px;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }
      .metric-card {
        background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        border: 2px solid #e1e4e8;
      }
      .metric-value {
        font-size: 32px;
        font-weight: bold;
        color: #667eea;
        margin-bottom: 5px;
      }
      .metric-label {
        font-size: 13px;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .transcript-box {
        background: #f8f9fa;
        border: 2px solid #e1e4e8;
        border-radius: 8px;
        padding: 15px;
        height: 400px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.6;
        margin-top: 10px;
      }
      .transcript-line {
        padding: 10px;
        margin-bottom: 8px;
        background: white;
        border-radius: 6px;
        border-left: 3px solid #667eea;
      }
      .transcript-line.customer {
        border-left-color: #764ba2;
      }
      .speaker {
        font-weight: bold;
        color: #667eea;
        margin-right: 8px;
      }
      .speaker.customer {
        color: #764ba2;
      }
      .timestamp {
        color: #999;
        font-size: 11px;
        margin-left: 8px;
      }
      .empty-state {
        text-align: center;
        color: #999;
        padding: 40px 20px;
      }
      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }
      .status-indicator.active {
        background: #28a745;
        box-shadow: 0 0 10px #28a745;
        animation: pulse 2s infinite;
      }
      .status-indicator.inactive {
        background: #dc3545;
      }
      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }
      #toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ff6b6b;
        color: white;
        padding: 20px 25px;
        border-radius: 8px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        display: none;
        z-index: 1000;
        max-width: 400px;
        font-weight: 600;
        font-size: 16px;
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      .info-box {
        background: #e7f3ff;
        border: 1px solid #b3d9ff;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
        font-size: 14px;
        color: #004085;
      }
      .debug-section {
        background: #f0f0f0;
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 10px;
        margin-top: 15px;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body onload="start()">
    <div class="content-wrapper">
      <div class="header-section">
        <h3>üéß Survey Monitor - Real-time Transcript Analysis</h3>
        <p>Monitors conversation transcripts to ensure survey is offered before wrap-up</p>
      </div>

      <div class="config-section">
        <div class="info-box" id="statusBox">
          <span class="status-indicator inactive" id="statusIndicator"></span>
          <span id="statusText">Not connected - Please authenticate</span>
        </div>

        <div class="control-row">
          <gux-dropdown filter-type="starts-with" placeholder="Select Conversation (optional)" id="conversationDropdown" style="width: 350px">
            <gux-listbox id="conversationList" aria-label="Conversations"> </gux-listbox>
          </gux-dropdown>
          <gux-button accent="primary" onclick="startMonitoring()">Start Monitoring</gux-button>
          <gux-button accent="secondary" onclick="stopMonitoring()" id="stopBtn" disabled>Stop Monitoring</gux-button>
          <gux-button accent="secondary" onclick="refreshConversations()">Refresh Conversations</gux-button>
          <gux-button accent="ghost" onclick="testAlert()">Test Alert</gux-button>
        </div>

        <div class="control-row">
          <input type="text" id="manualConvId" placeholder="Or enter Conversation ID manually" style="width: 350px; padding: 8px; border-radius: 4px; border: 1px solid #ccc" />
        </div>

        <div class="debug-section" id="debugLog" style="display: none;">
          <strong>Debug Log:</strong>
          <div id="debugContent"></div>
        </div>
        <gux-button accent="ghost" onclick="toggleDebug()" style="margin-top: 10px;">Toggle Debug</gux-button>
      </div>

      <div class="metrics-grid">
        <div class="metric-card">
          <div class="metric-value" id="callDuration">00:00</div>
          <div class="metric-label">Call Duration</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="surveyDetected">NO</div>
          <div class="metric-label">Survey Offered</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="messageCount">0</div>
          <div class="metric-label">Transcripts</div>
        </div>
        <div class="metric-card">
          <div class="metric-value" id="alertCount">0</div>
          <div class="metric-label">Alerts Sent</div>
        </div>
      </div>

      <div>
        <h4>Live Transcript</h4>
        <div class="transcript-box" id="transcriptBox">
          <div class="empty-state">
            <p>üí¨ Waiting for conversation data...</p>
            <p style="font-size: 12px; margin-top: 10px">Automatically monitoring your active conversations</p>
          </div>
        </div>
      </div>

      <div id="spinner" style="justify-self: center; padding: 20px; display: none">
        <gux-radial-loading id="loading" class="loading" screenreader-text="Loading..."></gux-radial-loading>
      </div>
    </div>

    <div id="toast">
      <span style="font-size: 24px; margin-right: 10px">‚ö†Ô∏è</span>
      <span id="toastMessage"></span>
    </div>

    <script>
      'use strict'
      
      let url = new URL(document.location.href)
      let gc_region = url.searchParams.get('gc_region')
      let gc_clientId = url.searchParams.get('gc_clientId')
      let gc_redirectUrl = url.searchParams.get('gc_redirectUrl')

      // Getting and setting the GC details from dynamic URL and session storage
      gc_region ? sessionStorage.setItem('gc_region', gc_region) : (gc_region = sessionStorage.getItem('gc_region'))
      gc_clientId ? sessionStorage.setItem('gc_clientId', gc_clientId) : (gc_clientId = sessionStorage.getItem('gc_clientId'))
      gc_redirectUrl ? sessionStorage.setItem('gc_redirectUrl', gc_redirectUrl) : (gc_redirectUrl = sessionStorage.getItem('gc_redirectUrl'))

      let platformClient = require('platformClient')
      const client = platformClient.ApiClient.instance
      const notificationsApi = new platformClient.NotificationsApi()
      const conversationsApi = new platformClient.ConversationsApi()
      const usersApi = new platformClient.UsersApi()

      // Configure Client App
      const ClientApp = window.purecloud.apps.ClientApp
      const myClientApp = new ClientApp({
        pcEnvironment: gc_region,
      })

      let websocket = null
      let channelId = null
      let heardSurvey = false
      let alertsSent = 0
      let messageCount = 0
      let callStartTime = null
      let durationInterval = null
      let currentConversationId = null
      let currentUserId = null

      // Keywords to detect
      const surveyKeywords = /survey|feedback|questionnaire|rate your experience|quick questions|how did we do|satisfaction/i
      const closingPhrases = /before i let you go|anything else i can help with|thanks for your time|thank you for calling|have a (great|good|nice) day|we're all set|is that everything|take care/i

      function debugLog(message) {
        console.log(message)
        const debugContent = document.getElementById('debugContent')
        if (debugContent) {
          const timestamp = new Date().toLocaleTimeString()
          debugContent.innerHTML += `<div>[${timestamp}] ${message}</div>`
          debugContent.scrollTop = debugContent.scrollHeight
        }
      }

      function toggleDebug() {
        const debugSection = document.getElementById('debugLog')
        debugSection.style.display = debugSection.style.display === 'none' ? 'block' : 'none'
      }

      async function start() {
        try {
          client.setEnvironment(gc_region)
          client.setPersistSettings(true, '_survey_monitor_')

          debugLog('Logging in to Genesys Cloud...')
          await client.loginImplicitGrant(gc_clientId, gc_redirectUrl, {})
          
          notification('Success', 'Successfully authenticated to Genesys Cloud')
          updateStatus('Authenticated - Looking for active conversations...', 'success')
          
          // Get current user ID
          const userInfo = await usersApi.getUsersMe()
          currentUserId = userInfo.id
          debugLog(`Current User ID: ${currentUserId}`)
          debugLog(`Current User Name: ${userInfo.name}`)
          
          // Auto-start monitoring for active conversations
          await autoStartMonitoring()
          
        } catch (err) {
          debugLog(`Error: ${err.message}`)
          console.log('Error: ', err)
          notification('Error', `Authentication failed: ${err.message}`)
          updateStatus('Authentication failed', 'error')
        }
      }

      async function autoStartMonitoring() {
        try {
          document.getElementById('spinner').style.display = 'block'
          
          debugLog('Fetching active conversations...')
          
          // Load active conversations
          const response = await conversationsApi.getConversationsCalls({ pageSize: 25 })
          debugLog(`API returned ${response.entities?.length || 0} conversations`)
          
          // Populate dropdown and find user conversations
          const dropdown = document.getElementById('conversationList')
          dropdown.innerHTML = ''

          let userConversation = null
          let userConversations = []

          if (response.entities && response.entities.length > 0) {
            debugLog(`Processing ${response.entities.length} conversations...`)
            
            for (const conv of response.entities) {
              const convId = conv.id
              
              // Fetch detailed conversation info to get participant data
              try {
                const detailedConv = await conversationsApi.getConversationsCall(convId)
                debugLog(`Conversation ${convId}: ${detailedConv.participants?.length || 0} participants`)
                
                let option = document.createElement('gux-option')
                option.value = convId
                
                // Get participant info
                let participantInfo = ''
                let isUserInConversation = false
                let agentName = ''
                let customerName = ''
                
                if (detailedConv.participants && detailedConv.participants.length > 0) {
                  for (const participant of detailedConv.participants) {
                    const userId = participant.user?.id || participant.userId
                    debugLog(`  Participant: ${participant.name} (${participant.purpose}) - User ID: ${userId || 'N/A'}`)
                    
                    if (participant.purpose === 'customer' || participant.purpose === 'external') {
                      customerName = participant.name || 'Customer'
                    }
                    
                    if (participant.purpose === 'agent' || participant.purpose === 'acd' || participant.purpose === 'user') {
                      agentName = participant.name || 'Agent'
                      
                      // Check if this is the current user
                      if (userId === currentUserId) {
                        isUserInConversation = true
                        userConversations.push(convId)
                        if (!userConversation) {
                          userConversation = convId
                        }
                        debugLog(`  ‚úì MATCH: Current user is in this conversation!`)
                      }
                    }
                  }
                }
                
                participantInfo = `${agentName} - ${customerName}`
                
                const startTime = new Date(detailedConv.conversationStart).toLocaleTimeString('en-AU')
                option.innerHTML = `${convId.substring(0, 8)}... | ${startTime} | ${participantInfo}${isUserInConversation ? ' ‚≠ê (You)' : ''}`
                dropdown.appendChild(option)
              } catch (detailError) {
                debugLog(`  Error fetching details for ${convId}: ${detailError.message}`)
              }
            }
            
            debugLog(`Found ${userConversations.length} conversations with current user`)
            
            // Auto-start monitoring if user has an active conversation
            if (userConversation) {
              debugLog(`Auto-starting monitoring for: ${userConversation}`)
              document.getElementById('conversationDropdown').value = userConversation
              notification('Info', 'Auto-starting monitoring for your active conversation')
              updateStatus('Auto-starting monitoring...', 'info')
              
              // Start monitoring automatically
              currentConversationId = userConversation
              await init(userConversation)
              document.getElementById('stopBtn').disabled = false
            } else {
              debugLog('No conversations found with current user as participant')
              notification('Info', `Found ${response.entities.length} active conversations (none with you as participant)`)
              updateStatus('No active conversations found for you - Select one to monitor', 'info')
            }
          } else {
            debugLog('No active conversations found at all')
            notification('Info', 'No active conversations found')
            updateStatus('No active conversations - Waiting for calls...', 'info')
          }
          
          document.getElementById('spinner').style.display = 'none'
        } catch (err) {
          debugLog(`Error in auto-start: ${err.message}`)
          console.error('Error in auto-start:', err)
          notification('Error', `Failed to auto-start: ${err.message}`)
          document.getElementById('spinner').style.display = 'none'
          updateStatus('Ready to monitor', 'info')
        }
      }

      async function refreshConversations() {
        await autoStartMonitoring()
      }

      async function startMonitoring() {
        try {
          // Get conversation ID from dropdown or manual input
          let conversationId = document.getElementById('conversationDropdown').value || document.getElementById('manualConvId').value.trim()

          if (!conversationId) {
            notification('Warning', 'Please select or enter a conversation ID')
            return
          }

          document.getElementById('spinner').style.display = 'block'
          updateStatus('Starting monitoring...', 'info')
          debugLog(`Manually starting monitoring for: ${conversationId}`)

          currentConversationId = conversationId
          await init(conversationId)

          document.getElementById('stopBtn').disabled = false
          document.getElementById('spinner').style.display = 'none'
        } catch (err) {
          debugLog(`Error starting monitoring: ${err.message}`)
          console.error('Error starting monitoring:', err)
          notification('Error', `Failed to start monitoring: ${err.message}`)
          updateStatus('Monitoring failed', 'error')
          document.getElementById('spinner').style.display = 'none'
        }
      }

      async function init(conversationId) {
        try {
          updateStatus('Creating notification channel...', 'info')
          debugLog('Creating notification channel...')

          // 1) Create a notifications channel
          const channel = await notificationsApi.postNotificationsChannels()
          channelId = channel.id
          debugLog(`Channel created: ${channelId}`)

          // 2) Subscribe to transcription AND user's conversation events
          const transcriptionTopic = `v2.conversations.${conversationId}.transcription`
          const userConversationsTopic = `v2.users.${currentUserId}.conversations.calls`
          
          debugLog(`Subscribing to topics:`)
          debugLog(`  - ${transcriptionTopic}`)
          debugLog(`  - ${userConversationsTopic}`)
          
          await notificationsApi.postNotificationsChannelSubscriptions(channelId, [
            { id: transcriptionTopic },
            { id: userConversationsTopic }
          ])

          updateStatus('Opening WebSocket connection...', 'info')
          debugLog(`Opening WebSocket: ${channel.connectUri}`)

          // 3) Open WebSocket
          websocket = new WebSocket(channel.connectUri)

          websocket.onopen = () => {
            debugLog('WebSocket connected!')
            updateStatus(`Connected - Monitoring ${conversationId.substring(0, 8)}...`, 'success')
            callStartTime = Date.now()
            heardSurvey = false
            alertsSent = 0
            messageCount = 0

            // Start duration counter
            durationInterval = setInterval(updateCallDuration, 1000)
          }

          websocket.onmessage = (evt) => {
            const msg = JSON.parse(evt.data)
            debugLog(`WebSocket message: ${msg.topicName}`)

            // Handle transcription messages
            if (msg.topicName && msg.topicName.includes('transcription')) {
              handleTranscriptionMessage(msg)
            }
            
            // Handle user's conversation state changes
            if (msg.topicName && msg.topicName.includes('users') && msg.topicName.includes('conversations.calls')) {
              handleUserConversationStateChange(msg)
            }
          }

          websocket.onerror = (error) => {
            debugLog(`WebSocket error: ${error}`)
            console.error('WebSocket error:', error)
            updateStatus('WebSocket error occurred', 'error')
          }

          websocket.onclose = () => {
            debugLog('WebSocket closed')
            updateStatus('WebSocket connection closed', 'warning')
            cleanup()
          }
        } catch (error) {
          debugLog(`Initialisation error: ${error.message}`)
          console.error('Initialisation error:', error)
          throw error
        }
      }

      function handleTranscriptionMessage(msg) {
        const eventBody = msg.eventBody
        if (!eventBody || !eventBody.transcripts) return

        // Extract transcript text
        const transcripts = eventBody.transcripts
        transcripts.forEach((transcript) => {
          const alternatives = transcript.alternatives || []
          if (alternatives.length === 0) return

          const text = alternatives[0].transcript || ''
          if (!text) return

          // Channel is uppercase 'INTERNAL' not lowercase
          const speaker = transcript.channel === 'INTERNAL' ? 'Agent' : 'Customer'
          const textLower = text.toLowerCase()

          debugLog(`Transcript (${speaker}): ${text} [channel: ${transcript.channel}]`)

          // Add to display
          addTranscriptLine(speaker, text)

          // Check for survey mention
          if (surveyKeywords.test(textLower)) {
            heardSurvey = true
            document.getElementById('surveyDetected').textContent = 'YES'
            document.getElementById('surveyDetected').style.color = '#28a745'
            debugLog('Survey keyword detected!')
          }

          // Check for closing phrases
          if (closingPhrases.test(textLower) && !heardSurvey) {
            alertsSent++
            document.getElementById('alertCount').textContent = alertsSent
            debugLog('Closing phrase detected WITHOUT survey mention - sending alert!')
            showToast('Please mention survey to customer')
          }
        })
      }

      function handleUserConversationStateChange(msg) {
        const eventBody = msg.eventBody
        if (!eventBody) return

        // Check if this is about our monitored conversation
        const conversationId = eventBody.id || eventBody.conversationId
        
        if (conversationId !== currentConversationId) {
          debugLog(`State change for different conversation: ${conversationId}`)
          return
        }

        debugLog(`State change for monitored conversation: ${conversationId}`)

        // FIXED: Check participant state directly, not in a nested calls array
        // Only close when conversation actually ends (all participants disconnected)
        if (eventBody.participants) {
          let participantStates = []
          
          // Log all participant states for debugging
          eventBody.participants.forEach(p => {
            const state = p.state || 'unknown'
            const purpose = p.purpose || 'unknown'
            participantStates.push(`${purpose}:${state}`)
            debugLog(`  Participant ${purpose}: state=${state}, muted=${p.muted}`)
          })

          // Only consider conversation ended if ALL participants are 'disconnected'
          const allDisconnected = eventBody.participants.every(p => p.state === 'disconnected')

          debugLog(`  All participants disconnected? ${allDisconnected} (states: ${participantStates.join(', ')})`)

          if (allDisconnected) {
            debugLog('‚úì All participants disconnected - conversation ended')
            notification('Info', 'Conversation ended - stopping monitoring')
            updateStatus('Conversation ended - monitoring stopped', 'warning')
            stopMonitoring()
          } else {
            debugLog('  Conversation still active (mute/unmute or other state change)')
          }
        }
      }

      function stopMonitoring() {
        debugLog('Stopping monitoring...')
        if (websocket) {
          websocket.close()
        }
        cleanup()
        updateStatus('Monitoring stopped', 'info')
      }

      function cleanup() {
        if (durationInterval) {
          clearInterval(durationInterval)
          durationInterval = null
        }

        websocket = null
        channelId = null
        callStartTime = null
        currentConversationId = null

        document.getElementById('stopBtn').disabled = true
      }

      function updateStatus(text, type = 'info') {
        const statusBox = document.getElementById('statusBox')
        const statusText = document.getElementById('statusText')
        const indicator = document.getElementById('statusIndicator')

        statusText.textContent = text

        // Update indicator
        if (type === 'success') {
          indicator.classList.add('active')
          indicator.classList.remove('inactive')
          statusBox.style.background = '#d4edda'
          statusBox.style.color = '#155724'
          statusBox.style.borderColor = '#c3e6cb'
        } else if (type === 'error') {
          indicator.classList.remove('active')
          indicator.classList.add('inactive')
          statusBox.style.background = '#f8d7da'
          statusBox.style.color = '#721c24'
          statusBox.style.borderColor = '#f5c6cb'
        } else if (type === 'warning') {
          indicator.classList.remove('active')
          indicator.classList.add('inactive')
          statusBox.style.background = '#fff3cd'
          statusBox.style.color = '#856404'
          statusBox.style.borderColor = '#ffeaa7'
        } else {
          indicator.classList.remove('active')
          indicator.classList.add('inactive')
          statusBox.style.background = '#d1ecf1'
          statusBox.style.color = '#0c5460'
          statusBox.style.borderColor = '#bee5eb'
        }
      }

      function addTranscriptLine(speaker, text, timestamp = new Date()) {
        const transcriptBox = document.getElementById('transcriptBox')

        // Remove empty state if present
        const emptyState = transcriptBox.querySelector('.empty-state')
        if (emptyState) {
          transcriptBox.innerHTML = ''
        }

        const line = document.createElement('div')
        line.className = `transcript-line ${speaker.toLowerCase()}`

        const time = timestamp.toLocaleTimeString('en-AU', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        })

        line.innerHTML = `
          <span class="speaker ${speaker.toLowerCase()}">${speaker}:</span>
          ${text}
          <span class="timestamp">${time}</span>
        `

        transcriptBox.appendChild(line)
        transcriptBox.scrollTop = transcriptBox.scrollHeight

        messageCount++
        document.getElementById('messageCount').textContent = messageCount
      }

      function showToast(message) {
        const toast = document.getElementById('toast')
        const toastMessage = document.getElementById('toastMessage')

        toastMessage.textContent = message
        toast.style.display = 'block'

        // Auto-hide after 10 seconds
        setTimeout(() => {
          toast.style.display = 'none'
        }, 10000)

        // Play audio alert
        playAlertSound(message)
        
        // Show toast notification if in iframe
        notification('Warning', message)
      }

      function playAlertSound(message) {
        if ('speechSynthesis' in window) {
          // Cancel any ongoing speech
          window.speechSynthesis.cancel()

          const utterance = new SpeechSynthesisUtterance(message)
          utterance.rate = 0.9
          utterance.pitch = 1.0
          utterance.volume = 1.0
          utterance.lang = 'en-AU'

          window.speechSynthesis.speak(utterance)
        }
      }

      function updateCallDuration() {
        if (!callStartTime) return

        const elapsed = Math.floor((Date.now() - callStartTime) / 1000)
        const minutes = Math.floor(elapsed / 60)
        const seconds = elapsed % 60

        document.getElementById('callDuration').textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`
      }

      function testAlert() {
        showToast('Please mention survey to customer')
      }

      function notification(type, message) {
        if (window.location !== window.parent.location) {
          // if in an iframe (Genesys Cloud)
          myClientApp.alerting.showToastPopup(type, message)
          return
        }
        console.log(`${type}: ${message}`)
        return
      }

      // Handle page unload
      window.addEventListener('beforeunload', () => {
        if (websocket) {
          websocket.close()
        }
      })
    </script>
  </body>
</html>
